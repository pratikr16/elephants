---
  editor_options:
    chunk_output_type: console
  chunk_output_type: console
---
# Temp fates of incoming eles

# Load libs

```{r load_libs, message=FALSE, warning=FALSE}
#set env
library(plyr);library(dplyr);library(purrr);library(purrrlyr);library(data.table);library(lubridate);library(tidyr)

library(ggplot2)
```

```{r ggplot_theme}
source("libs.R")
source("elecode2.6dataloading.r")
source("ggplot.opts.r")
```

```{r get_data}
#load("ele_after_move.rdata")
```

# Filter data
Filter data to include only:
1. Incoming eles, waterdiff > -500:+500
2. Distwater <= 500
3. All points satisfying both above, and the next 10 points.

```{r temp_fates_data}
#'work on the split ele02 as etf1, ie, ele temp fates 1
ele2$id = ele2$from.idData.rep.1..n.locs.from.....

ele2 = ele2 %>% dlply("id") %>%
  map(function(x) plyr::arrange(x, time) %>% mutate(tempdiff = c(NA, diff(temp, lag = 1)), waterdiff = c(diff(mindw, lag = 1), NA))) %>% bind_rows()

#'split into list of 13
etf1 = ele2 %>% dlply("id") %>% map(function(x) mutate(x, arrival = ifelse(waterdiff < 0 & mindw <=500, "arrival", "other")))

#'split each df into a list by the arrival event
etf2 = etf1 %>% map(function(x) x %>% dlply("arrival"))

#'find the timediff in the arrival events df
for(i in 1:13){
  x = etf2[[i]]$arrival
  etf2[[i]]$arrival$timediff = c(NA, difftime(x$time[-1], x$time[-dim(x)[1]], units = "hours"))
  etf2[[i]]$arrival = etf2[[i]]$arrival %>% filter(timediff > 5)
}

#'bind rows
etf3 = etf2 %>% map(rbind_list) %>% map(function(x) arrange(x, time))
```

```{r id_consecutive_points}
#'find the next 10 points at each arrival event
for(i in 1:13){
  a = which(etf3[[i]]$arrival == "arrival")
  y = unique(sort(a + rep(-10:10, each = length(a))))
  y = y[y>0]
  etf3[[i]] = etf3[[i]][y,]
}

etf3 = etf3 %>% map(function(x) x = x %>% mutate(event = cumsum(arrival == "arrival"), event.inv = event+1))

#etf3 = etf3 %>% map(function(x) x = x %>% dlply("event") %>% map(function(y) y = mutate(y, watertime = difftime(time, time[1]))))
```

```{r water_time_tempchange}
#'bind the lists
etf4 = etf3 %>% map(function(x) x = x %>% group_by(event) %>% mutate(watertime = difftime(time, time[1], units = "hours"), deltadw = mindw - mindw[1]))

#### Prior to arrival ####
#'make an etf5 for prior to arrival events
etf5 = etf3 %>% map(function(x) x = x %>% group_by(event.inv = ifelse(arrival == "arrival", event, event.inv)) %>% mutate(watertime = difftime(time, time[length(time)], units = "hours"), deltadw = mindw - mindw[length(mindw)]))

#'bind rows
etf4 = as.data.frame(bind_rows(etf4))

#'now for pre-arrival
etf5 = as.data.frame(bind_rows(etf5))
```

# Run model

```{r run_glmm_tempchange_watertime,eval=FALSE}
#'run a glmm
library(lme4)
mod.tempchange = lmer(tempchange ~ watertime + distw + season2 + (1|id), data = etf4)

summary(mod.tempchange)
```

# Fig 8. Temp change with time at water

```{r tempchange_watertime}
#'get data

etf.fig = 
  etf4 %>% 
#  mutate(pred = predict(mod.deltawd, newdata = etf4, allow.new.levels = T, scale = "response")) %>% 
  group_by(watertime = round_any(as.numeric(watertime), 0.5), season2) %>% 
  summarise(deltawd.mean = mean(deltadw, na.rm = T), deltawd.sd = sd(deltadw, na.rm = T), deltawd.n = length(deltadw)#, predmean = mean(pred, na.rm = T), predsd = sd(pred, na.rm = T), predn = length(pred)
            ) %>% 
  
mutate(deltawd.ci = qnorm(0.975)*deltawd.sd/sqrt(deltawd.n)#,#pred.ci = qnorm(0.975)*predsd/sqrt(predn)
       )
```

# ETF inverse: Changes in distance to water prior to arrival

```{r}
etf.fig.inv = etf5 %>% 
#  mutate(pred = predict(mod.deltawd, newdata = etf4, allow.new.levels = T, scale = "response")) %>% 
  group_by(watertime = round_any(as.numeric(watertime), 0.5), season2) %>% 
  summarise(deltawd.mean = mean(deltadw, na.rm = T), deltawd.sd = sd(deltadw, na.rm = T), deltawd.n = length(deltadw)#, predmean = mean(pred, na.rm = T), predsd = sd(pred, na.rm = T), predn = length(pred)
            ) %>% 
  
mutate(deltawd.ci = qnorm(0.975)*deltawd.sd/sqrt(deltawd.n)#,#pred.ci = qnorm(0.975)*predsd/sqrt(predn)
       )
```

# Merge data for pre- and post-arrival

```{r}
etf.merged = rbind(etf.fig, etf.fig.inv) %>% filter(watertime > -12, watertime < 12)
```


```{r fig8.tempchange.watertime}
#'plot fig 6

#png(filename = "fig8tempchange_watertime.png", height = 1600, width = 1600, res = 500)

cairo_pdf(filename = "fig4circ.pdf", height = 4, width = 4, fallback_resolution = 600)

ggplot()+
   geom_vline(aes(xintercept = seq(-12,0,12)), lty = 2, col = 1, lwd = 0.2)+
 # geom_smooth(aes(x = watertime, y = predmean, col = season2, fill = season2), lwd = 0.5)+
  geom_rect(aes(xmin = -12, xmax = 12, ymin = -5e2, ymax = 0), fill = "grey80")+
  
   geom_hline(yintercept = seq(-500, 2000, 500), lty = 1, col = c("royalblue", rep("grey",5)), lwd = c(1,rep(0.1,5)))+
  
 
  #geom_pointrange(aes(x = watertime, y = deltawd.mean, ymin = deltawd.mean-deltawd.ci, ymax = deltawd.mean+deltawd.ci, col = season2, shape = season2), fill = "white", fatten = 7, stroke = 0.6, lty = 1, lwd = 0.2, position = position_dodge(width = 0.3))+
 
   geom_bar(data = etf.merged,aes(x = watertime, y = deltawd.mean, fill = season2), stat = "identity", position = "identity", alpha = 0.5)+
  
  
  
  geom_text(aes(x = 0, y = seq(5e2, 2e3, 5e2), label = c("500m","1000m","1500m","2000m")), vjust = "outward", size = 2)+
  geom_text(aes(x = 0, y = -1000, label = "water"), col = "royalblue")+
 
 # scale_colour_manual(values = c(cola,colb))+
  scale_fill_manual(values = c("royalblue3",colb))+
 # scale_shape_manual(values = c(21, 24))+
  theme_bw()+g1+
  labs(list(x = NULL, y = NULL))+
  xlim(-12,12)+ ylim(-1000, 2e3)+
 coord_polar(start = pi, theta = "x")+
  theme(axis.ticks.y = element_blank(), axis.text.y = element_blank())+
    scale_x_continuous(breaks = seq(-12,11,1))

dev.off()
```


